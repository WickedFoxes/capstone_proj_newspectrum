<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title th:text="${news_article.title}">뉴스 상세</title>

    <!-- 외부 스타일/스크립트 -->
    <link rel="stylesheet" th:href="@{/css/header.css}">

    <style>
        body {
            font-family: Arial, sans-serif;
            background: #f4f6f8;
            margin: 0;
            padding: 0;
        }

        .news-container {
            max-width: 900px;
            margin: 40px auto;
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }

        .news-title {
            font-size: 30px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }

        .news-meta {
            font-size: 14px;
            color: #888;
            margin-bottom: 20px;
        }

        .news-img {
            width: 100%;
            height: auto;
            max-height: 400px;
            object-fit: contain;
        }

        .news-content {
            font-size: 18px;
            line-height: 1.8;
            color: #444;
            white-space: pre-wrap;
            margin-top: 30px;
        }

        .focus-keyword {
            font-weight: bold;
            color: #d9534f;
        }

        .related-news-scroll {
            display: flex;
            overflow-x: auto;
            overflow-y: hidden;
            white-space: nowrap;
            padding: 10px 20px;
            scroll-behavior: smooth;
            background: linear-gradient(to right, #ffffff, #000000);
            border-radius: 8px;
        }

        .related-news-item {
            flex: 0 0 auto;
            width: 200px;
            margin-right: 20px;
            border-radius: 8px;
            background-color: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: hidden;
            transition: transform 0.3s ease;
        }

        .related-news-item:hover {
            transform: translateY(-5px);
        }

        .related-news-item a {
            text-decoration: none;
            color: inherit;
            display: block;
        }

        .related-news-item img {
            width: 100%;
            height: 120px;
            object-fit: cover;
        }

        .related-news-item .title {
            font-size: 14px;
            padding: 10px;
        }

        .section-title {
            font-size: 20px;
            margin-top: 30px;
            margin-bottom: 10px;
            color: #333;
        }

        .ai-summary-list li {
            font-size: 16px;
            margin-bottom: 8px;
            color: #444;
        }

        .ai-image-wrapper {
            text-align: center;
            margin: 15px 0 30px 0;
        }
        .ai-image-wrapper img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
        }

        /* 품질 점수 그래프 - 더 작은 크기 */
        .quality-graph-wrapper {
            position: fixed;
            top: 120px;
            right: 20px;
            width: 250px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.12);
            padding: 18px;
            z-index: 1000;
            transition: all 0.3s ease;
            border: 1px solid #e9ecef;
        }

        .quality-graph-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
            text-align: center;
            border-bottom: 2px solid #eee;
            padding-bottom: 8px;
        }

        .graph-section {
            margin-bottom: 18px;
        }

        .graph-section-title {
            font-size: 13px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #555;
            padding: 6px 8px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 3px solid #6c757d;
        }

        .bar-item {
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            padding: 6px;
            border-radius: 6px;
            border: 1px solid transparent;
        }

        .bar-item:hover {
            transform: translateX(3px);
            border-color: #6c757d;
            background: #f8f9ff;
        }

        .bar-label {
            font-size: 11px;
            color: #666;
            margin-bottom: 3px;
            font-weight: 500;
            text-transform: capitalize;
        }

        .bar-container {
            background: #f0f0f0;
            border-radius: 8px;
            height: 18px;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }

        .bar-fill {
            height: 100%;
            border-radius: 8px;
            transition: width 0.6s ease;
            position: relative;
        }

        .bar-score {
            position: absolute;
            right: 6px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.3);
        }

        /* 점수에 따른 색상 */
        .score-high {
            background: linear-gradient(90deg, #ff6b6b, #ff8e8e);
        }
        .score-medium {
            background: linear-gradient(90deg, #feca57, #ffd93d);
        }
        .score-low {
            background: linear-gradient(90deg, #48dbfb, #0abde3);
        }

        /* 상세 모달 */
        .detail-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .detail-modal-content {
            background-color: white;
            margin: 8% auto;
            padding: 35px;
            border-radius: 15px;
            width: 85%;
            max-width: 550px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.3);
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .detail-modal-title {
            font-size: 22px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #333;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        .detail-modal-score {
            font-size: 20px;
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-weight: bold;
            color: white;
        }

        .detail-modal-description {
            font-size: 16px;
            line-height: 1.7;
            color: #555;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }

        .modal-close {
            color: #aaa;
            float: right;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s ease;
            line-height: 1;
        }

        .modal-close:hover {
            color: #ff6b6b;
        }

        .detail-modal-examples {
            background: #fff8e1;
            border: 1px solid #ffcc02;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            max-height: 300px;
            overflow-y: auto;
        }

        .detail-modal-examples h4 {
            margin: 0 0 10px 0;
            color: #f57c00;
            font-size: 14px;
            position: sticky;
            top: 0;
            background: #fff8e1;
            padding-bottom: 5px;
            z-index: 10;
        }

        .example-sentence {
            background: #fff3e0;
            padding: 8px 12px;
            border-radius: 6px;
            margin: 8px 0;
            border-left: 3px solid #ff9800;
            font-size: 14px;
            line-height: 1.4;
        }

        .problem-sentence {
            background: #ffebee;
            border-left: 3px solid #f44336;
        }

        .highlight-problem {
            background: #ffebee;
            color: #c62828;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: bold;
        }

        /* 범례도 더 작게 */
        .score-legend {
            display: flex;
            justify-content: space-between;
            margin-top: 12px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 6px;
            font-size: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .legend-color {
            width: 10px;
            height: 10px;
            border-radius: 2px;
        }

        .type-group {
            margin-bottom: 25px;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            overflow: hidden;
        }

        .type-group-header {
            background: linear-gradient(135deg, #ff6b6b, #ff8e8e);
            color: white;
            padding: 12px 15px;
            font-weight: bold;
            font-size: 16px;
        }

        .type-group-content {
            padding: 15px;
            background: #fff;
        }

        .problem-sentence-item {
            background: #fff3e0;
            padding: 12px 15px;
            border-radius: 6px;
            margin: 10px 0;
            border-left: 4px solid #ff9800;
            transition: all 0.3s ease;
        }

        .problem-sentence-item:hover {
            background: #ffebee;
            transform: translateX(3px);
        }

        .sentence-score {
            font-size: 12px;
            color: #c62828;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .sentence-text {
            line-height: 1.5;
            color: #333;
        }

        /* 반응형 - 더 작은 브레이크포인트 */
        @media (max-width: 1300px) {
            .quality-graph-wrapper {
                width: 220px;
                padding: 15px;
            }
        }

        @media (max-width: 1100px) {
            .quality-graph-wrapper {
                display: none;
            }
        }
    </style>
</head>
<body>

<!-- 공통 상단바 삽입 -->
<div th:replace="layout/common/header :: header"></div>

<!-- 품질 점수 그래프 - 더 작고 간결한 버전 -->
<div class="quality-graph-wrapper" id="qualityGraph">
    <div class="quality-graph-title">기사 퀄리티 분석</div>

    <!-- 제목 퀄리티 -->
    <div class="graph-section" th:if="${news_article.title_checks != null and !news_article.title_checks.isEmpty()}">
        <div class="graph-section-title">제목 퀄리티</div>
        <div th:each="titleCheck, stat : ${news_article.title_checks}"
             th:if="${stat.index < 3}"
             class="bar-item title-check-item"
             th:attr="data-type=${titleCheck.content_check_type}, data-score=${titleCheck.score}"
             onclick="openDetailModal(this, 'title')">
            <div class="bar-label" th:text="${titleCheck.content_check_type.name() == 'title_normal'} ? '정상 표현' :
                                            (${titleCheck.content_check_type.name() == 'title_hidden_1'} ? '의문 유발(부호)' :
                                            (${titleCheck.content_check_type.name() == 'title_hidden_2'} ? '의문 유발(은닉)' :
                                            (${titleCheck.content_check_type.name() == 'title_sensation'} ? '선정 표현' :
                                            (${titleCheck.content_check_type.name() == 'title_slang'} ? '속어/줄임말 사용' :
                                            (${titleCheck.content_check_type.name() == 'title_over_representation'} ? '과대 표현' :
                                            (${titleCheck.content_check_type.name() == 'title_intentional_distortion'} ? '주어 의도적 왜곡' : ${titleCheck.content_check_type.name()}))))))">검사 항목</div>
            <div class="bar-container">
                <div class="bar-fill"
                     th:classappend="${titleCheck.content_check_type.name() == 'title_normal'} ? (${titleCheck.score >= 0.7} ? 'score-low' : 'score-medium') : (${titleCheck.score >= 0.7} ? 'score-high' : (${titleCheck.score >= 0.4} ? 'score-medium' : 'score-low'))"
                     th:style="|width: ${titleCheck.score * 100}%|">
                    <span class="bar-score" th:text="${#numbers.formatDecimal(titleCheck.score, 1, 3)}">0.000</span>
                </div>
            </div>
        </div>
    </div>

    <!-- 본문 퀄리티 -->
    <div class="graph-section">
        <div class="graph-section-title">본문 퀄리티</div>

        <!-- 도넛 차트 영역 (클릭 가능) -->
        <div style="margin-top: 15px; text-align: center; cursor: pointer;" onclick="openContentQualityModal()">
            <canvas id="problemRatioChart" width="180" height="180" style="max-width: 180px; max-height: 180px; border: none;"></canvas>
            <div id="chartLegend" style="font-size: 10px; margin-top: 8px;">
                <!-- 범례가 여기에 표시됩니다 -->
            </div>
            <div style="font-size: 11px; color: #666; margin-top: 5px;">클릭하여 상세 분석 보기</div>
        </div>
    </div>

    <!-- 간소화된 범례 -->
    <div class="score-legend">
        <div class="legend-item">
            <div class="legend-color score-high"></div>
            <span>문제</span>
        </div>
        <div class="legend-item">
            <div class="legend-color score-medium"></div>
            <span>주의</span>
        </div>
        <div class="legend-item">
            <div class="legend-color score-low"></div>
            <span>양호</span>
        </div>
    </div>
</div>

<!-- 제목 검사 상세 정보 모달 -->
<div id="detailModal" class="detail-modal">
    <div class="detail-modal-content">
        <span class="modal-close" onclick="closeDetailModal()">&times;</span>
        <div class="detail-modal-title" id="detailTitle">검사 상세 정보</div>
        <div class="detail-modal-score" id="detailScore">점수: 0.00</div>
        <div class="detail-modal-description" id="detailDescription">상세 설명이 여기에 표시됩니다.</div>
        <div class="detail-modal-examples" id="detailKeywords" style="display: none;">
            <h4>🔍 검사 대상 문장/키워드</h4>
            <div id="keywordContent"></div>
        </div>
    </div>
</div>

<!-- 본문 퀄리티 분석 모달 -->
<div id="contentQualityModal" class="detail-modal">
    <div class="detail-modal-content" style="max-width: 700px; width: 90%;">
        <span class="modal-close" onclick="closeContentQualityModal()">&times;</span>
        <div class="detail-modal-title">본문 퀄리티 분석</div>

        <div id="contentQualityResults" style="max-height: 500px; overflow-y: auto;">
            <!-- JavaScript로 동적 생성 -->
        </div>
    </div>
</div>

<!-- 뉴스 기사 컨테이너 -->
<div class="news-container">
    <div class="news-title" th:text="${news_article.title}">기사 제목</div>
    <div class="news-meta">
        <span th:text="${news_article.media}">언론사</span> |
        <span th:text="${#temporals.format(news_article.createdDate, 'yyyy-MM-dd HH:mm')}">날짜</span>
    </div>

    <!-- 키워드 리스트 강조 출력 -->
    <div class="news-meta" style="margin-top: 5px;">
      <span th:each="kw, stat : ${keyword_items}" th:if="${stat.index < 5}"
            th:text="|#${kw.keyword} |"
            style="font-weight: bold; color: #555;">
        #키워드
      </span>
    </div>

    <!-- AI 뉴스 요약 - 2열 레이아웃으로 변경 -->
    <div class="section-title">🧠 AI 뉴스 요약</div>
    <div style="display: flex; gap: 30px; margin-bottom: 30px;">
        <!-- 왼쪽: AI 이미지 -->
        <div style="flex: 1;">
            <div class="ai-image-wrapper" style="margin: 0;">
                <img th:src="@{'/img/' + ${news_article.comics_url}}" alt="AI 요약 이미지">
            </div>
        </div>

        <!-- 오른쪽: AI 요약 텍스트 -->
        <div style="flex: 1;">
            <ol class="ai-summary-list" style="margin: 0; padding-left: 20px;">
                <li th:each="line : ${summaryLines}" th:text="${line}">요약 문장</li>
            </ol>
        </div>
    </div>

    <!-- 뉴스 이미지 추가 -->
    <img class="news-img" th:src="${news_article.img_url}" alt="뉴스 이미지">

    <div class="news-content" th:utext="${news_article.content}">
        <!-- 본문 내용 -->
    </div>

    <!-- 같이 보면 좋은 기사 -->
    <div class="section-title">연관 뉴스 추천</div>
    <div class="related-news-scroll" onwheel="scrollHorizontally(event)">
        <div class="related-news-item" th:each="related : ${related_news_articles}"
             th:href="@{/view/{id}(id=${related.news_article.id})}">
            <a th:href="@{/view/{id}(id=${related.news_article.id})}">
                <img th:src="${related.news_article.img_url}" alt="관련 뉴스 이미지">
                <div class="title" th:text="${related.news_article.title}">관련 뉴스 제목</div>
            </a>
        </div>
    </div>
</div>

<!-- 숨겨진 데이터 저장소 (새로운 구조에 맞게 수정) -->
<div id="allContentChecksData" style="display: none;">
    <div th:each="typeEntry : ${news_article.content_checks}">
        <div th:each="keywordEntry : ${typeEntry.value}">
            <div th:each="check : ${keywordEntry.value}"
                 th:attr="data-type=${check.content_check_type}, data-score=${check.score}, data-keyword=${check.keyword}">
            </div>
        </div>
    </div>
</div>

<!-- Title checks 키워드 정보도 저장 -->
<div id="titleChecksData" style="display: none;">
    <div th:each="titleCheck : ${news_article.title_checks}"
         th:attr="data-type=${titleCheck.content_check_type}, data-score=${titleCheck.score}, data-keyword=${titleCheck.keyword}">
    </div>
</div>

<script>
    // 타입명을 한글로 변환하는 함수
    function getKoreanTypeName(englishType) {
        const typeNames = {
            'title_normal': '정상 표현',
            'title_hidden_1': '의문 유발(부호)',
            'title_hidden_2': '의문 유발(은닉)',
            'title_sensation': '선정 표현',
            'title_slang': '속어/줄임말 사용',
            'title_over_representation': '과대 표현',
            'title_intentional_distortion': '주어 의도적 왜곡',
            'content_normal': '정상 표현',
            'content_advertisement_1': '판매정보 노출(상품)',
            'content_advertisement_2': '판매정보 노출(부동산)',
            'content_advertisement_3': '판매정보 노출(서비스)',
            'content_intentional_distortion': '의도적 상황 왜곡'
        };

        return typeNames[englishType] || englishType;
    }

    // 스크롤 따라다니는 그래프 위젯
    const qualityGraph = document.getElementById('qualityGraph');
    let isScrolling = false;

    window.addEventListener('scroll', () => {
        if (!isScrolling) {
            window.requestAnimationFrame(() => {
                const scrollY = window.scrollY;
                const newTop = 120 + (scrollY * 0.05);
                qualityGraph.style.top = `${newTop}px`;
                isScrolling = false;
            });
        }
        isScrolling = true;
    });

    // 모든 Content Checks 데이터 읽기 (새로운 구조 대응)
    function getAllContentChecksData() {
        const dataContainer = document.getElementById('allContentChecksData');
        const allData = [];

        // 모든 체크 데이터 수집
        const checkElements = dataContainer.querySelectorAll('[data-type][data-score][data-keyword]');

        checkElements.forEach(element => {
            const type = element.getAttribute('data-type');
            const score = parseFloat(element.getAttribute('data-score'));
            const keyword = element.getAttribute('data-keyword');

            allData.push({
                type: type,
                score: score,
                keyword: keyword
            });
        });

        console.log('전체 Content Checks 데이터:', allData.length, '개');
        return allData;
    }

    // **핵심 수정: 통일된 문제 문장 탐지 로직**
    function getProblemSentencesForChart() {
        const allData = getAllContentChecksData();

        if (allData.length === 0) {
            return {
                totalSentences: 0,
                problemSentences: 0,
                normalSentences: 0,
                problemsByType: {}
            };
        }

        // content_ 타입만 필터링하고 키워드별로 그룹화
        const keywordGroups = {};
        allData.forEach(item => {
            if (item.type && item.type.startsWith('content_')) {
                if (!keywordGroups[item.keyword]) {
                    keywordGroups[item.keyword] = [];
                }
                keywordGroups[item.keyword].push(item);
            }
        });

        let totalSentences = 0;
        let problemSentences = 0;
        const problemsByType = {};

        // 각 키워드(문장)별로 가장 높은 점수의 타입 확인
        for (const keyword in keywordGroups) {
            const checks = keywordGroups[keyword];
            totalSentences++;

            // 가장 높은 점수와 해당 타입 찾기
            let maxScore = 0;
            let maxType = null;

            checks.forEach(check => {
                if (check.score > maxScore) {
                    maxScore = check.score;
                    maxType = check.type;
                }
            });

            // normal이 아니고 임계값(0.3) 이상이면 문제 문장으로 분류
            if (maxType !== 'content_normal' && maxScore > 0.3) {
                problemSentences++;

                // 타입별로 문제 문장 저장
                if (!problemsByType[maxType]) {
                    problemsByType[maxType] = [];
                }
                problemsByType[maxType].push({
                    text: keyword,
                    score: maxScore
                });
            }
        }

        // 각 타입별로 점수 내림차순 정렬
        for (const type in problemsByType) {
            problemsByType[type].sort((a, b) => b.score - a.score);
        }

        const normalSentences = totalSentences - problemSentences;

        console.log(`문제 탐지 결과: 총 ${totalSentences}개, 문제 ${problemSentences}개, 정상 ${normalSentences}개`);
        console.log('타입별 문제 문장:', problemsByType);

        return {
            totalSentences,
            problemSentences,
            normalSentences,
            problemsByType
        };
    }

    // 문제 문장 비율 계산 및 도넛 차트 생성
    function createProblemRatioChart() {
        const result = getProblemSentencesForChart();
        const { totalSentences, problemSentences, normalSentences } = result;

        const problemRatio = totalSentences > 0 ? (problemSentences / totalSentences * 100) : 0;

        console.log(`차트용 데이터: 총 문장 ${totalSentences}, 문제 문장 ${problemSentences}, 비율 ${problemRatio.toFixed(1)}%`);

        // 도넛 차트 생성
        const canvas = document.getElementById('problemRatioChart');
        if (!canvas) {
            console.log('캔버스를 찾을 수 없습니다.');
            return result;
        }

        const ctx = canvas.getContext('2d');

        // 캔버스 초기화
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = 70;
        const innerRadius = 35;

        // 전체 원 배경
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
        ctx.fillStyle = '#f0f0f0';
        ctx.fill();

        if (totalSentences > 0) {
            // 문제 문장 비율 (빨간색)
            if (problemSentences > 0) {
                const problemAngle = 2 * Math.PI * (problemSentences / totalSentences);
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, -Math.PI/2, -Math.PI/2 + problemAngle);
                ctx.lineTo(centerX + Math.cos(-Math.PI/2 + problemAngle) * innerRadius,
                          centerY + Math.sin(-Math.PI/2 + problemAngle) * innerRadius);
                ctx.arc(centerX, centerY, innerRadius, -Math.PI/2 + problemAngle, -Math.PI/2, true);
                ctx.closePath();
                ctx.fillStyle = '#ff6b6b';
                ctx.fill();
            }

            // 정상 문장 비율 (파란색)
            if (normalSentences > 0) {
                const problemAngle = 2 * Math.PI * (problemSentences / totalSentences);
                const normalAngle = 2 * Math.PI * (normalSentences / totalSentences);
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, -Math.PI/2 + problemAngle, -Math.PI/2 + problemAngle + normalAngle);
                ctx.lineTo(centerX + Math.cos(-Math.PI/2 + problemAngle + normalAngle) * innerRadius,
                          centerY + Math.sin(-Math.PI/2 + problemAngle + normalAngle) * innerRadius);
                ctx.arc(centerX, centerY, innerRadius, -Math.PI/2 + problemAngle + normalAngle, -Math.PI/2 + problemAngle, true);
                ctx.closePath();
                ctx.fillStyle = '#48dbfb';
                ctx.fill();
            }
        }

        // 내부 원 (도넛 구멍)
        ctx.beginPath();
        ctx.arc(centerX, centerY, innerRadius, 0, 2 * Math.PI);
        ctx.fillStyle = 'white';
        ctx.fill();

        // 중앙 텍스트
        ctx.fillStyle = '#333';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(`${problemRatio.toFixed(1)}%`, centerX, centerY - 8);
        ctx.font = '11px Arial';
        ctx.fillText('문제 비율', centerX, centerY + 8);

        // 범례 업데이트
        const legend = document.getElementById('chartLegend');
        if (legend) {
            legend.innerHTML = `
                <div style="display: flex; justify-content: center; gap: 10px;">
                    <div style="display: flex; align-items: center; gap: 3px;">
                        <div style="width: 8px; height: 8px; background: #ff6b6b; border-radius: 50%;"></div>
                        <span>문제 (${problemSentences})</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 3px;">
                        <div style="width: 8px; height: 8px; background: #48dbfb; border-radius: 50%;"></div>
                        <span>정상 (${normalSentences})</span>
                    </div>
                </div>
            `;
        }

        return result;
    }

    // **수정된 본문 퀄리티 분석 모달 열기 - 차트와 동일한 로직 사용**
    function openContentQualityModal() {
        const modal = document.getElementById('contentQualityModal');
        const resultsContainer = document.getElementById('contentQualityResults');

        // 차트와 동일한 로직으로 문제 문장 탐지
        const result = getProblemSentencesForChart();
        const { totalSentences, problemSentences, normalSentences, problemsByType } = result;

        let resultHtml = '';

        if (Object.keys(problemsByType).length === 0) {
            resultHtml = `
                <div style="text-align: center; padding: 40px; color: #48dbfb;">
                    <div style="font-size: 48px; margin-bottom: 20px;">✅</div>
                    <div style="font-size: 18px; font-weight: bold; margin-bottom: 10px;">모든 문장이 양호합니다!</div>
                    <div style="font-size: 14px; color: #666;">문제가 있는 문장이 발견되지 않았습니다.</div>
                    <div style="font-size: 14px; color: #666; margin-top: 10px;">
                        총 ${totalSentences}개 문장을 분석했습니다.
                    </div>
                </div>
            `;
        } else {
            const totalProblemCount = Object.values(problemsByType).reduce((sum, arr) => sum + arr.length, 0);

            resultHtml = `
                <div style="margin-bottom: 20px; padding: 15px; background: #e3f2fd; border-radius: 8px;">
                    <div style="font-size: 16px; font-weight: bold; color: #1976d2;">
                        📊 검출된 문제 유형: ${Object.keys(problemsByType).length}개
                    </div>
                    <div style="font-size: 14px; color: #666; margin-top: 5px;">
                        총 ${totalSentences}개 문장 중 ${totalProblemCount}개 문장에서 문제 발견
                        (${((totalProblemCount / totalSentences) * 100).toFixed(1)}%)
                    </div>
                </div>
            `;

            // 타입별로 문제 문장들 표시
            for (const type in problemsByType) {
                const sentences = problemsByType[type];
                const typeInfo = checkDescriptions[type] || { title: type };

                resultHtml += `
                    <div class="type-group">
                        <div class="type-group-header">
                            ${typeInfo.title} (${sentences.length}개 문장)
                        </div>
                        <div class="type-group-content">
                `;

                sentences.forEach((sentence, index) => {
                    const shortText = sentence.text.length > 200 ?
                        sentence.text.substring(0, 200) + '...' :
                        sentence.text;

                    resultHtml += `
                        <div class="problem-sentence-item">
                            <div class="sentence-score">위험도: ${sentence.score.toFixed(6)}</div>
                            <div class="sentence-text">"${shortText}"</div>
                        </div>
                    `;
                });

                resultHtml += `
                        </div>
                    </div>
                `;
            }
        }

        resultsContainer.innerHTML = resultHtml;
        modal.style.display = 'block';
    }

    // 본문 퀄리티 분석 모달 닫기
    function closeContentQualityModal() {
        document.getElementById('contentQualityModal').style.display = 'none';
    }

    // Content Checks 그래프 렌더링 (도넛 차트만)
    function renderContentChecks() {
        // 도넛 차트 생성 및 결과 반환
        const result = createProblemRatioChart();
        console.log('렌더링 완료:', result);
        return result;
    }

    // **기존 함수는 하위 호환성을 위해 유지하되 새로운 통합 함수 사용**
    function getProblemSentences(checkType) {
        // 새로운 통합 로직 사용
        const result = getProblemSentencesForChart();
        const problemsByType = result.problemsByType;

        if (problemsByType[checkType]) {
            return problemsByType[checkType];
        }

        return [];
    }

    // 검사 타입별 상세 설명 (모든 타입 포함)
    const checkDescriptions = {
        // 제목 관련
        'title_normal': {
            title: '정상 표현',
            description: '제목이 과도하게 자극적이거나 선정적이지 않고, 일반적이고 객관적인 표현을 사용하는지 검사합니다.'
        },
        'title_hidden_1': {
            title: '의문 유발(부호)',
            description: '제목에 의문을 유발하는 부호나 표현이 사용되어 독자의 호기심을 자극하는지 검사합니다. 예: "손흥민 우승의 비결은 바로 이것!"'
        },
        'title_hidden_2': {
            title: '의문 유발(은닉)',
            description: '제목에서 핵심 내용을 의도적으로 숨겨 독자의 호기심을 자극하는 표현이 사용되었는지 검사합니다.'
        },
        'title_sensation': {
            title: '선정 표현',
            description: '제목에 독자의 관심을 끌기 위한 선정적이거나 자극적인 표현이 사용되었는지 검사합니다. 예: "충격 고백! 톱스타 A, 10년간 숨겨온 비밀 연애 전격 공개"'
        },
        'title_slang': {
            title: '속어/줄임말 사용',
            description: '제목에 부적절한 속어, 은어, 줄임말 또는 격식에 맞지 않는 표현이 사용되었는지 검사합니다. 예: "한화 T1 상대로 승리! 지렸다!"'
        },
        'title_over_representation': {
            title: '과대 표현',
            description: '제목에 과장되거나 과도한 표현이 사용되어 실제보다 부풀려서 표현되었는지 검사합니다. 예: "한국 로또가 숨긴 당첨의 비밀, 로또 업계에서 비밀 밝혀져.. 업계 비상!"'
        },
        'title_intentional_distortion': {
            title: '주어 의도적 왜곡(주어 숨김)',
            description: '제목에서 주어를 의도적으로 숨기거나 왜곡하여 오해를 불러일으킬 수 있는 표현을 사용하는지 검사합니다. 예: "윤 대통령의 선택은? 지명 막바지로 접어들어..."'
        },

        // 내용 관련
        'content_normal': {
            title: '정상 표현',
            description: '기사 내용이 객관적이고 균형 잡힌 시각으로 작성되었는지 검사합니다.'
        },
        'content_advertisement_1': {
            title: '판매정보 노출(상품 판매정보)',
            description: '기사 내용에 상품 판매를 목적으로 하는 광고성 내용이 포함되어 있는지 검사합니다. 예: 특정 상품이나 서비스의 판매 정보가 기사에 은밀하게 포함된 경우'
        },
        'content_advertisement_2': {
            title: '판매정보 노출(부동산 판매정보)',
            description: '기사 내용에 부동산 판매나 투자를 목적으로 하는 광고성 내용이 포함되어 있는지 검사합니다.'
        },
        'content_advertisement_3': {
            title: '판매정보 노출(서비스 판매정보)',
            description: '기사 내용에 서비스 판매나 홍보를 목적으로 하는 광고성 내용이 포함되어 있는지 검사합니다.'
        },
        'content_intentional_distortion': {
            title: '의도적 상황 왜곡',
            description: '기사 내용에서 실제 상황을 의도적으로 왜곡하거나 편향된 시각으로 서술하여 독자에게 잘못된 인식을 심어줄 수 있는지 검사합니다.'
        }
    };

    // 해당 타입의 실제 키워드들 찾기 (새로운 구조 대응)
    function findActualKeywords(checkType, type) {
        const keywords = [];

        if (type === 'title') {
            // Title checks에서 해당 타입의 키워드 찾기
            const titleDataContainer = document.getElementById('titleChecksData');
            const titleElements = titleDataContainer.querySelectorAll(`[data-type="${checkType}"]`);

            titleElements.forEach(element => {
                const keyword = element.getAttribute('data-keyword');
                const score = element.getAttribute('data-score');
                if (keyword && keyword.trim() !== '') {
                    keywords.push({
                        text: keyword,
                        score: parseFloat(score)
                    });
                }
            });
        } else if (type === 'content') {
            // Content checks에서 해당 타입의 키워드들 찾기
            const allData = getAllContentChecksData();

            // 해당 타입의 데이터만 필터링
            const typeData = allData.filter(item => item.type === checkType);

            typeData.forEach(item => {
                if (item.keyword && item.keyword.trim() !== '') {
                    keywords.push({
                        text: item.keyword,
                        score: item.score
                    });
                }
            });
        }

        // 점수 내림차순으로 정렬
        keywords.sort((a, b) => b.score - a.score);

        return keywords;
    }

    // 모달 열기 (실제 키워드 표시)
    function openDetailModal(element, type) {
        const checkType = element.getAttribute('data-type');
        const score = parseFloat(element.getAttribute('data-score'));
        const count = element.getAttribute('data-count');

        const modal = document.getElementById('detailModal');
        const title = document.getElementById('detailTitle');
        const scoreElement = document.getElementById('detailScore');
        const description = document.getElementById('detailDescription');
        const keywordsDiv = document.getElementById('detailKeywords');
        const keywordContent = document.getElementById('keywordContent');

        const checkInfo = checkDescriptions[checkType] || {
            title: '검사 항목',
            description: '해당 검사 항목에 대한 상세 설명입니다.'
        };

        title.textContent = `${type === 'title' ? '제목' : '내용'} - ${checkInfo.title}`;

        if (type === 'content' && count) {
            scoreElement.textContent = `평균 위험도: ${score.toFixed(6)} (${count}개 데이터)`;
        } else {
            scoreElement.textContent = `위험도 점수: ${score.toFixed(6)}`;
        }

        // 점수에 따른 색상 설정
        const isNormalType = checkType.includes('normal');
        if (isNormalType) {
            if (score >= 0.7) {
                scoreElement.style.background = 'linear-gradient(135deg, #48dbfb, #0abde3)';
            } else if (score >= 0.4) {
                scoreElement.style.background = 'linear-gradient(135deg, #feca57, #ffd93d)';
            } else {
                scoreElement.style.background = 'linear-gradient(135deg, #ff6b6b, #ff8e8e)';
            }
        } else {
            if (score >= 0.7) {
                scoreElement.style.background = 'linear-gradient(135deg, #ff6b6b, #ff8e8e)';
            } else if (score >= 0.4) {
                scoreElement.style.background = 'linear-gradient(135deg, #feca57, #ffd93d)';
            } else {
                scoreElement.style.background = 'linear-gradient(135deg, #48dbfb, #0abde3)';
            }
        }

        // 설명과 해석 추가
        let interpretation = '';
        if (isNormalType) {
            if (score >= 0.7) {
                interpretation = '<br><br><strong style="color: #48dbfb;">✅ 우수: 매우 양호한 수준입니다.</strong><br>이 항목에서 높은 점수가 나온 것은 기사의 품질이 우수함을 의미합니다.';
            } else if (score >= 0.4) {
                interpretation = '<br><br><strong style="color: #feca57;">⚠️ 보통: 개선 여지가 있는 수준입니다.</strong><br>기본적인 품질은 갖추고 있지만 더 나은 품질을 위해 개선이 필요합니다.';
            } else {
                interpretation = '<br><br><strong style="color: #ff6b6b;">🚨 주의: 품질 개선이 필요합니다.</strong><br>이 항목에서 낮은 점수가 나온 것은 품질 향상이 필요함을 의미합니다.';
            }
        } else {
            if (score >= 0.7) {
                interpretation = '<br><br><strong style="color: #ff6b6b;">🚨 위험: 즉시 검토가 필요한 수준입니다.</strong><br>이 항목에서 높은 점수가 나왔다는 것은 해당 부분에 문제가 있을 가능성이 높음을 의미합니다.';
            } else if (score >= 0.4) {
                interpretation = '<br><br><strong style="color: #feca57;">⚠️ 주의: 개선이 권장되는 수준입니다.</strong><br>완전히 문제가 있다고 볼 수는 없지만, 더 나은 품질을 위해 검토해볼 필요가 있습니다.';
            } else {
                interpretation = '<br><br><strong style="color: #48dbfb;">✅ 양호: 품질이 우수한 수준입니다.</strong><br>이 항목에서는 특별한 문제가 발견되지 않았습니다.';
            }
        }

        description.innerHTML = checkInfo.description + interpretation;

        // 실제 키워드들 표시 (문제 문장만 필터링)
        if (type === 'content') {
            const problemSentences = getProblemSentences(checkType);

            if (problemSentences.length > 0) {
                let keywordHtml = `<div style="font-size: 12px; color: #666; margin-bottom: 10px;">문제가 있는 문장: ${problemSentences.length}개</div>`;

                problemSentences.forEach((item, index) => {
                    const shortText = item.text.length > 150 ?
                        item.text.substring(0, 150) + '...' :
                        item.text;

                    keywordHtml += `
                        <div class="example-sentence problem-sentence">
                            <div style="font-size: 12px; color: #c62828; margin-bottom: 5px; font-weight: bold;">
                                위험도: ${item.score.toFixed(6)}
                            </div>
                            <div style="line-height: 1.4;">
                                "${shortText}"
                            </div>
                        </div>
                    `;
                });

                keywordContent.innerHTML = keywordHtml;
                keywordsDiv.style.display = 'block';
            } else {
                keywordContent.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">이 타입에서 문제가 있는 문장이 발견되지 않았습니다.</div>';
                keywordsDiv.style.display = 'block';
            }
        } else {
            // Title checks는 기존 방식 유지
            const actualKeywords = findActualKeywords(checkType, type);
            if (actualKeywords.length > 0) {
                let keywordHtml = '';

                const displayKeywords = actualKeywords.slice(0, 5);

                displayKeywords.forEach((item, index) => {
                    const shortText = item.text.length > 100 ?
                        item.text.substring(0, 100) + '...' :
                        item.text;

                    keywordHtml += `
                        <div class="example-sentence">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">
                                점수: ${item.score.toFixed(6)}
                            </div>
                            <div style="line-height: 1.4;">
                                "${shortText}"
                            </div>
                        </div>
                    `;
                });

                if (actualKeywords.length > 5) {
                    keywordHtml += `<div style="font-size: 12px; color: #999; text-align: center; margin-top: 10px;">외 ${actualKeywords.length - 5}개 더...</div>`;
                }

                keywordContent.innerHTML = keywordHtml;
                keywordsDiv.style.display = 'block';
            } else {
                keywordsDiv.style.display = 'none';
            }
        }

        modal.style.display = 'block';
    }

    // 모달 닫기
    function closeDetailModal() {
        document.getElementById('detailModal').style.display = 'none';
    }

    // ESC 키로 모달 닫기
    window.addEventListener('keydown', function (e) {
        if (e.key === 'Escape') {
            closeDetailModal();
            closeContentQualityModal();
        }
    });

    // 바깥 클릭 시 닫기
    window.onclick = function(event) {
        const detailModal = document.getElementById("detailModal");
        const contentQualityModal = document.getElementById("contentQualityModal");
        if (event.target === detailModal) {
            closeDetailModal();
        }
        if (event.target === contentQualityModal) {
            closeContentQualityModal();
        }
    }

    // 가로 스크롤 함수
    function scrollHorizontally(event) {
        event.preventDefault();
        event.currentTarget.scrollLeft += event.deltaY;
    }

    // 페이지 로드 시 Content Checks 렌더링
    window.addEventListener('load', function() {
        console.log('페이지 로드 완료 - 도넛 차트 버전');

        // Content Checks 도넛 차트 생성
        renderContentChecks();

        // 그래프 애니메이션
        setTimeout(() => {
            const barFills = document.querySelectorAll('.bar-fill');
            barFills.forEach((bar, index) => {
                setTimeout(() => {
                    bar.style.width = bar.style.width; // 애니메이션 트리거
                }, index * 200);
            });
        }, 100);
    });
</script>

</body>
</html>